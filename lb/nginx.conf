worker_processes auto;

events { worker_connections 1024; }

http {
    # 1) Prefer query param ?route=; otherwise use cookie
    map $arg_route $route_candidate {
        ""      $cookie_route;
        default $arg_route;
    }

    # 2) If still empty, use a per-request id so new users distribute evenly
    map $route_candidate $route_final {
        ""      $request_id;
        default $route_candidate;
    }

    # 3) Proper Connection header for WebSockets
    map $http_upgrade $connection_upgrade {
        default upgrade;
        ""      close;
    }

    upstream chess_backend {
        hash $route_final consistent;
        server host.docker.internal:8081 max_fails=3 fail_timeout=10s;
        server host.docker.internal:8082 max_fails=3 fail_timeout=10s;
    }

    server {
        listen 8080;

        location = /health {
            return 200 "OK\n";
        }

        location / {
            # Always refresh the stickiness cookie (even on 101 Switching Protocols)
            add_header Set-Cookie "route=$route_final; Path=/; HttpOnly; SameSite=Lax" always;

            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;

            proxy_set_header Host $host;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Request-ID $request_id;

            proxy_read_timeout 3600s;
            proxy_send_timeout 3600s;
            proxy_buffering off;

            proxy_next_upstream error timeout invalid_header http_502 http_503 http_504;

            proxy_pass http://chess_backend;
        }
    }
}
